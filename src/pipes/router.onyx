package http.server

use runtime
use core {tprintf}

Router :: struct {
    routes: [..] Route;

    // Prepended to every route
    base_path := "";
}

#inject Router {
    collect_routes :: router_collect_routes
    route          :: router_add_route
    all            :: #solidify __quick_route {method=HTTP_Method.ALL}
    get            :: #solidify __quick_route {method=HTTP_Method.GET}
    post           :: #solidify __quick_route {method=HTTP_Method.POST}
    put            :: #solidify __quick_route {method=HTTP_Method.PUT}
    patch          :: #solidify __quick_route {method=HTTP_Method.PATCH}
    delete         :: #solidify __quick_route {method=HTTP_Method.DELETE}

    route_request :: router_route_request
}

HTTP_Handler :: #type (&Request, &Response) -> void;

#package
Route :: struct {
    method:  HTTP_Method;
    elems: [] Elem;
    pipeline: Pipeline;
    
    Elem :: struct {
        pattern: str;
        is_variable: bool;
    }
}

route :: struct {
    method: HTTP_Method;
    route:  str;
}

middleware :: struct {
    func: HTTP_Handler;
}

router :: (base_path := "") -> Router {
    r: Router;

    r.base_path = base_path;
    r.routes    = make([..] Route, allocator=long_term_allocator);

    return r;
}

#package
router_add_route :: #match #local {}


//
// This case is special, because without it, it is not possible
// to say router->route(.GET, "/", (req, res) => {...}), as the
// polymorphic procedure does not match. This is not entirely
// correct behavior and may be due to an underlying compiler
// bug. Either way, for now this overload has to be here.
#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, handle: HTTP_Handler) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes(router);
}

#overload
router_add_route :: macro (router: &Router, method: HTTP_Method, route: str, pipeline: Pipeline) {
    Route :: Route
    router.routes << Route.{
        method = method,
        pipeline = pipeline,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: macro (router: &Router, route: str, handle: $T/Pipeable) {
    router->route(.ALL, route, handle);
}

#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, handle: $T/Pipeable) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, steps: ..Pipe) {
    pipes := pipeline();
    for steps do pipes->add(it);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}


#local
__quick_route :: (router: &Router, $method: HTTP_Method, route: str, handle: HTTP_Handler) {
    router_add_route(router, method, route, handle);
}

#package
router_collect_routes :: (router: &Router, pack := builtin.any_package) {
    procs := runtime.info.get_procedures_with_tag(route);
    for procs {
        if pack != any_package && pack != it.pack do continue;

        pipes := pipeline();
        for tag: runtime.info.get_tags_for_procedure(it.func) {
            if tag.type == middleware {
                mw := cast(&middleware) tag.data;
                pipes->add(mw.func);
            }
        }

        pipes->add(*cast(&HTTP_Handler) &it.func);

        router_add_route(router, it.tag.method, it.tag.route, pipes);
    }
}

#local
sort_routes :: (router: &Router) {
    core.slice.sort(router.routes, (a, b) => {
        first_param_a := core.slice.find(a.elems, #(it.is_variable));
        first_param_b := core.slice.find(b.elems, #(it.is_variable));
        
        if first_param_a != first_param_b {
            return first_param_a - first_param_b;
        }

        x1 := a.elems.count;
        x2 := b.elems.count;

        if x1 == x2 {
            return b.elems[b.elems.length - 1].pattern.length - a.elems[a.elems.length - 1].pattern.length;
        } else {
            return x2 - x1;
        }
    });
}


#package
router_route_request :: (router: &Router, req: &Request, res: &Response) {
    if !string.starts_with(req.endpoint, router.base_path) {
        return;
    }

    previous_endpoint := req.endpoint;
    defer req.endpoint = previous_endpoint;

    req.endpoint = req.endpoint[router.base_path.length .. req.endpoint.length];

    tmp_url_params: [..] struct { name, value: str; };
    
    for& router.routes {
        if it.method != .ALL && it.method != req.method do continue;
        core.array.clear(&tmp_url_params);

        consumed_length := 0;

        //
        // "/" is a special route.
        // The code below checks to see if the requested endpoint
        // begins with the same characters as the route being checked.
        // This works in almost all cases, and enables nesting routers.
        // However, if the route is "/" every single route will match
        // it, which is not the intended behavior. To avoid this, when
        // matching "/", the match has to be exact ("/"), or the empty
        // string("").  The empty string case allows a sub router to use
        // "/" as its route path. So when a user visits "/subroute",
        // it will match the "/" on the sub router, without the user
        // having to visit "/subroute/".
        if it.elems.count == 0 || req.endpoint == "/" || req.endpoint.length == 0 {
            if it.elems.count > 0 || (req.endpoint != "/" && req.endpoint.length > 0) {
                continue;
            }
        }
        else {
            total := 0;
            for parts: iter.zip(iter.as_iter(it.elems), string.split_iter(req.endpoint, '/')->skip(1)) {
                if !parts.first.is_variable {
                    if parts.first.pattern != parts.second {
                        // No match, skip the entire rest of this route.
                        continue continue;
                    }
                    consumed_length += parts.second.length + 1; // /xxx
                }
                else {
                    consumed_length += parts.second.length + 1;
                    tmp_url_params << .{ parts.first.pattern, parts.second };
                }

                total += 1;
            }

            if total != it.elems.count || total != core.slice.count_where(req.endpoint, #(it == '/')) {
                continue;
            }
        }

        for tmp_url_params do req.url_params[it.name] = it.value;

        req.endpoint = req.endpoint[consumed_length .. req.endpoint.length];
        it.pipeline->process(req, res);
        return;
    }

    res->status(404);
}

#local
process_url_to_route_elems :: (s: str) -> [] Route.Elem {
    if s == "/" do return .{};

    if s[0] != '/' {
        log(.Warning, "HTTP-Server", tprintf("Poorly formatted route: {}", s));
        return .{};
    }

    elem_count := core.slice.count_where(s, #(it == '/'));
    elems := make([] Route.Elem, elem_count, long_term_allocator);

    for iter.enumerate(core.string.split_iter(s, '/')->skip(1)) {
        is_variable := it.value[0] == ':';
        pattern := it.value;
        if is_variable do string.advance(&pattern);

        elems[it.index] = .{ pattern, is_variable };
    }

    return elems;
}


#overload
convert_to_pipe :: macro (r: &Router) => Pipe.{router_route_request, r};
