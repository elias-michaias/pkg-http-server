package http

Router :: struct {
    routes: [..] Route;

    // Prepended to every route
    base_path := "";


    collect_routes :: router_collect_routes
    route          :: router_add_route
    get            :: #solidify __quick_route {method=HTTP_Method.GET}
    post           :: #solidify __quick_route {method=HTTP_Method.POST}
    put            :: #solidify __quick_route {method=HTTP_Method.PUT}
    patch          :: #solidify __quick_route {method=HTTP_Method.PATCH}
    delete         :: #solidify __quick_route {method=HTTP_Method.DELETE}

    route_request :: router_route_request
}

#package
Route :: struct {
    method:  HTTP_Method;
    pattern: Route_Pattern;
    handler: HTTP_Handler;
}

#package
Route_Pattern :: struct {
    @Temporary
    route: str;
}

route :: struct {
    method: HTTP_Method;
    route:  str;
    group := "";
}


router :: (base_path := "") -> Router {
    r: Router;

    r.base_path = base_path;
    r.routes    = make([..] Route, allocator=long_term_allocator);
    
    return r;
}

#package
router_add_route :: (router: ^Router, method: HTTP_Method, route: str, handle: HTTP_Handler) {
    router.routes << .{ 
        method = method,
        pattern = .{ route },
        handler = handle
    };
}

#local
__quick_route :: (router: ^Router, $method: HTTP_Method, route: str, handle: HTTP_Handler) {
    router_add_route(router, method, route, handle);
}

#package
router_collect_routes :: (router: ^Router, group := "") {
    procs := runtime.info.get_procedures_with_tag(http.route);
    for procs {
        if it.tag.group != group do continue;

        router_add_route(router, it.tag.method, it.tag.route, *cast(^HTTP_Handler) ^it.func);
    }
}


#package
router_route_request :: (router: ^Router, req: ^Request, res: ^Response) {
    if !string.starts_with(req.endpoint, router.base_path) {
        return;
    }

    endpoint := req.endpoint[router.base_path.length .. req.endpoint.length];

    for^ router.routes {
        if it.method == req.method && it.pattern.route == endpoint {
            it.handler(req, res);
            return;
        }
    }
}


#overload
convert_to_pipe :: (r: ^Router) -> Pipe {
    handler :: (r: ^Router, req: ^Request, res: ^Response) -> Pipeline.Action {
        router_route_request(r, req, res);
        return (.Finish) if res.completed else .Proceed;
    }

    return .{ handler, r };
}
