package http.server

use runtime
use core {tprintf}
use core.array

Router :: struct {
    routes: [..] Route;

    // Prepended to every route
    base_path := "";
}

#inject Router {
    collect_routes :: router_collect_routes
    route          :: router_add_route
    all            :: #solidify __quick_route {method=HTTP_Method.ALL}
    get            :: #solidify __quick_route {method=HTTP_Method.GET}
    post           :: #solidify __quick_route {method=HTTP_Method.POST}
    put            :: #solidify __quick_route {method=HTTP_Method.PUT}
    patch          :: #solidify __quick_route {method=HTTP_Method.PATCH}
    delete         :: #solidify __quick_route {method=HTTP_Method.DELETE}

    route_request :: router_route_request
}

HTTP_Handler :: #type (&Request, &Response) -> void;

#package
Route :: struct {
    method:  HTTP_Method;
    elems: [] Elem;
    pipeline: Pipeline;
    
    Elem :: union {
        Fixed: str;
        Variable: str;
    }
}

route :: struct {
    method: HTTP_Method;
    route:  str;
}

middleware :: struct {
    func: HTTP_Handler;
}

router :: (base_path := "") -> Router {
    r: Router;

    r.base_path = base_path;
    r.routes    = make([..] Route, allocator=long_term_allocator);

    return r;
}

#package
router_add_route :: #match #local {}


//
// This case is special, because without it, it is not possible
// to say router->route(.GET, "/", (req, res) => {...}), as the
// polymorphic procedure does not match. This is not entirely
// correct behavior and may be due to an underlying compiler
// bug. Either way, for now this overload has to be here.
#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, handle: HTTP_Handler) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes(router);
}

#overload
router_add_route :: macro (router: &Router, method: HTTP_Method, route: str, pipeline: Pipeline) {
    Route :: Route
    router.routes << Route.{
        method = method,
        pipeline = pipeline,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: macro (router: &Router, route: str, handle: $T/Pipeable) {
    router->route(.ALL, route, handle);
}

#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, handle: $T/Pipeable) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: (router: &Router, method: HTTP_Method, route: str, steps: ..Pipe) {
    pipes := pipeline();
    for steps do pipes->add(it);

    router.routes << Route.{
        method = method,
        pipeline = pipes,
        elems = process_url_to_route_elems(route),
    };

    sort_routes :: sort_routes
    sort_routes(router);
}


#local
__quick_route :: (router: &Router, $method: HTTP_Method, route: str, handle: HTTP_Handler) {
    router_add_route(router, method, route, handle);
}

#package
router_collect_routes :: (router: &Router, pack := builtin.any_package) {
    procs := runtime.info.get_procedures_with_tag(route);
    for procs {
        if pack != any_package && pack != it.pack do continue;

        pipes := pipeline();
        for tag: runtime.info.get_tags_for_procedure(it.func) {
            if tag.type == middleware {
                mw := cast(&middleware) tag.data;
                pipes->add(mw.func);
            }
        }

        pipes->add(*cast(&HTTP_Handler) &it.func);

        router_add_route(router, it.tag.method, it.tag.route, pipes);
    }
}

#local
pattern_length :: macro (v: Route.Elem) -> i32 {
    switch v {
        case .Variable => var_name do return var_name.length;
        case .Fixed    => fixed    do return fixed.length;
    }
}

#local
sort_routes :: (router: &Router) {
    core.slice.sort(router.routes, (a, b) => {
        first_param_a := core.slice.find(a.elems, #(it.tag == .Variable));
        first_param_b := core.slice.find(b.elems, #(it.tag == .Variable));
        
        if first_param_a != first_param_b {
            return first_param_b - first_param_a;
        }

        x1 := a.elems.count;
        x2 := b.elems.count;

        if x1 == x2 {
            return pattern_length(b.elems[b.elems.length - 1]) - pattern_length(a.elems[a.elems.length - 1]);
        } else {
            return x2 - x1;
        }
    });
}


#package
router_route_request :: (router: &Router, req: &Request, res: &Response) {
    if !string.starts_with(req.endpoint, router.base_path) {
        return;
    }

    previous_endpoint := req.endpoint;
    defer req.endpoint = previous_endpoint;

    req.endpoint = req.endpoint[router.base_path.length .. req.endpoint.length];

    tmp_url_params: [..] struct { name, value: str; };
    
    for& router.routes {
        if it.method != .ALL && it.method != req.method do continue;
        core.array.clear(&tmp_url_params);

        matched_parts := pattern_match_routes(it.elems, req._processed_endpoint, &tmp_url_params).Matched;
        if matched_parts {
            for tmp_url_params do req.url_params[it.name] = it.value;
            req._processed_endpoint = req._processed_endpoint[matched_parts? .. req._processed_endpoint.length];

            it.pipeline->process(req, res);
            return;
        }
    }

    res->status(404);
}

#local
PatternMatchResult :: union {
    NoMatch: void;
    Matched: i32;
}

#local
pattern_match_routes :: (expected: [] Route.Elem, actual: [] Route.Elem, variables: &$T) -> PatternMatchResult {
    matched_count := 0;
    for iter.zip(
        iter.as_iter(expected),
        iter.as_iter(actual))
    {
        if it.second.tag == .Variable {
            // Variables are illegal in provided `actual`
            return .{ NoMatch = .{} };
        }

        provided_pattern := it.second.Fixed?;

        switch it.first {
            case .Fixed => expected_pattern {
                if expected_pattern != provided_pattern do return .{ NoMatch = .{} };
            }

            case .Variable => variable_name {
                array.push(variables, .{ variable_name, provided_pattern });
            }
        }

        matched_count += 1;
    }

    if expected.count == 0 && actual.count != 0 {
        return .{ NoMatch = .{} };
    }

    if matched_count != expected.count {
        return .{ NoMatch = .{} };
    }

    return .{ Matched = matched_count };
}

#package
process_url_to_route_elems :: (s: str) -> [] Route.Elem {
    if s == "/" do return .{};

    if s[0] != '/' {
        log(.Warning, "HTTP-Server", tprintf("Poorly formatted route: {}", s));
        return .{};
    }

    elem_count := core.slice.count_where(s, #(it == '/'));
    elems := make([..] Route.Elem, elem_count, long_term_allocator);

    for core.string.split_iter(s, '/')->skip(1) {
        pattern := it;
        if it[0] == ':' {
            string.advance(&pattern);
            elems << .{ Variable = pattern };
        } else {
            elems << .{ Fixed = pattern };
        }
    }

    return elems;
}


#overload
convert_to_pipe :: macro (r: &Router) => Pipe.{router_route_request, r};
