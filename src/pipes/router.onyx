package http

Router :: struct {
    routes: [..] Route;

    // Prepended to every route
    base_path := "";


    collect_routes :: router_collect_routes
    route          :: router_add_route
    all            :: #solidify __quick_route {method=HTTP_Method.ALL}
    get            :: #solidify __quick_route {method=HTTP_Method.GET}
    post           :: #solidify __quick_route {method=HTTP_Method.POST}
    put            :: #solidify __quick_route {method=HTTP_Method.PUT}
    patch          :: #solidify __quick_route {method=HTTP_Method.PATCH}
    delete         :: #solidify __quick_route {method=HTTP_Method.DELETE}

    route_request :: router_route_request
}

HTTP_Handler :: #type (^Request, ^Response) -> void;

#package
Route :: struct {
    method:  HTTP_Method;
    pattern: str;
    pipeline: Pipeline;
}

route :: struct {
    method: HTTP_Method;
    route:  str;
}

middleware :: struct {
    func: HTTP_Handler; 
}

router :: (base_path := "") -> Router {
    r: Router;

    r.base_path = base_path;
    r.routes    = make([..] Route, allocator=long_term_allocator);
    
    return r;
}

#package
router_add_route :: #match #local {}


//
// This case is special, because without it, it is not possible
// to say router->route(.GET, "/", (req, res) => {...}), as the
// polymorphic procedure does not match. This is not entirely
// correct behavior and may be due to an underlying compiler
// bug. Either way, for now this overload has to be here.
#overload
router_add_route :: (router: ^Router, method: HTTP_Method, route: str, handle: HTTP_Handler) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << .{ 
        method = method,
        pattern = route,
        pipeline = pipes,
    };

    sort_routes(router);
}

#overload
router_add_route :: macro (router: ^Router, method: HTTP_Method, route: str, pipeline: Pipeline) {
    router.routes << .{ 
        method = method,
        pattern = route,
        pipeline = pipeline,
    };

    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: macro (router: ^Router, route: str, handle: $T) where Pipeable(T) {
    router->route(.ALL, route, handle);
}

#overload
router_add_route :: (router: ^Router, method: HTTP_Method, route: str, handle: $T) where Pipeable(T) {
    pipes := pipeline();
    pipes->add(handle);

    router.routes << .{ 
        method = method,
        pattern = route,
        pipeline = pipes,
    };
    
    sort_routes :: sort_routes
    sort_routes(router);
}

#overload
router_add_route :: (router: ^Router, method: HTTP_Method, route: str, steps: ..Pipe) {
    pipes := pipeline();
    for steps do pipes->add(it);

    router.routes << .{ 
        method = method,
        pattern = route,
        pipeline = pipes,
    };
    
    sort_routes :: sort_routes
    sort_routes(router);
}


#local
__quick_route :: (router: ^Router, $method: HTTP_Method, route: str, handle: HTTP_Handler) {
    router_add_route(router, method, route, handle);
}

#package
router_collect_routes :: (router: ^Router, pack := builtin.any_package) {
    procs := runtime.info.get_procedures_with_tag(route);
    for procs {
        if pack != any_package && pack != it.pack do continue;

        pipes := pipeline();
        for tag: runtime.info.get_tags_for_procedure(it.func) {
            if tag.type == middleware {
                mw := cast(^middleware) tag.data;
                pipes->add(mw.func);
            }
        }

        pipes->add(*cast(^HTTP_Handler) ^it.func);

        router_add_route(router, it.tag.method, it.tag.route, pipes);
    }
}

#local
sort_routes :: (router: ^Router) {
    core.array.sort(router.routes, (a, b) => {
        x1 := core.array.count_where(a.pattern, #(it == #char "/"));
        x2 := core.array.count_where(b.pattern, #(it == #char "/"));
        return x2 - x1;
    });
}


#package
router_route_request :: (router: ^Router, req: ^Request, res: ^Response) {
    if !string.starts_with(req.endpoint, router.base_path) {
        return;
    }

    previous_endpoint := req.endpoint;
    defer req.endpoint = previous_endpoint;

    req.endpoint = req.endpoint[router.base_path.length .. req.endpoint.length];

    for^ router.routes {
        if it.method != .ALL && it.method != req.method do continue;

        //
        // "/" is a special route.
        // The code below checks to see if the requested endpoint
        // begins with the same characters as the route being checked.
        // This works in almost all cases, and enables nesting routers.
        // However, if the route is "/" every single route will match
        // it, which is not the intended behavior. To avoid this, when
        // matching "/", the match has to be exact ("/"), or the empty
        // string("").  The empty string case allows a sub router to use
        // "/" as its route path. So when a user visits "/subroute",
        // it will match the "/" on the sub router, without the user
        // having to visit "/subroute/".
        if it.pattern == "/" {
            if req.endpoint != "/" && req.endpoint.length > 0 {
                continue;
            }
        }
        elseif !string.starts_with(req.endpoint, it.pattern) {
            continue;
        }

        req.endpoint = req.endpoint[it.pattern.length .. req.endpoint.length];
        it.pipeline->process(req, res);
        return;
    }
}


#overload
convert_to_pipe :: macro (r: ^Router) => Pipe.{router_route_request, r};
