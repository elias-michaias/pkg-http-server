package http.server

TCP_Server :: struct {
    server: &net.TCP_Server;
    pipeline: Pipeline;

    session_gc: alloc.gc.GCState;
}

#inject TCP_Server {
    serve :: tcp_serve;
}

tcp :: #match {}

#overload
tcp :: (pipeline: Pipeline) => TCP_Server.{ pipeline = pipeline };

#overload
tcp :: (p: $P/Pipeable) -> TCP_Server {
    pipe := pipeline();
    pipe->pipe(p);
    return TCP_Server.{ pipeline = pipe };
}

Serve_Status :: enum {
    Success;
    Failed_To_Bind;
}

#package
tcp_serve :: (tcp: &TCP_Server, port: u32) -> Serve_Status {
    tcp.session_gc = alloc.gc.make();

    tcp.server = net.tcp_server_make(max_clients=16);
    tcp.server.emit_data_events = false;

    // Allows the server to be immediately restarted. Not
    // the safest, but it is fine for a development instance.
    tcp.server.socket->setting(.ReuseAddress, 1);

    if !(tcp.server->listen(~~port)) {
        log(.Error, "HTTP-Server", core.tprintf("Failed to bind to port {}.\n", port));
        return .Success;
    }

    log(.Info, "HTTP-Server", core.tprintf("Serving on port {}", port));
    tcp.server->handle_events() {
        case .Connection {
            // Enable non-blocking communication on all sockets
            cast(&core.net.TCP_Event.Connection, it.data).client.socket->setting(.NonBlocking, 1);
        }

        case .Ready {
            ready_client := cast(&core.net.TCP_Event.Ready, it.data).client;
            if ready_client.socket.vtable == null || ready_client.state != .Alive {
                log(.Warning, "HTTP-Server", "Discarding dead client");
                ready_client->read_complete();
                continue;
            }

            use_gc_allocator_in_current_scope(&tcp.session_gc);
            defer alloc.clear_temp_allocator();

            if !handle_request(tcp, &ready_client.address, &ready_client.socket) {
                // If the request fails to parse, shutdown the connection.
                // Likely, this is actually due to the socket being empty
                // and/or already closed, but you can't tell until you try
                // to read from it.
                tcp.server->kill_client(ready_client);

            } else {
                ready_client->read_complete();
            }
        }
    }
}

#local
handle_request :: (tcp: &TCP_Server, req_address: &net.Socket_Address, s: &net.Socket) -> bool {
    req := Request.{ address = *req_address };
    defer request_free(&req);

    reader := io.reader_make(s);
    defer io.reader_free(&reader);

    //
    // Loop until there is no data buffered in the reader.
    // If two requests were sent back-to-back, there is a non-zero
    // chance the reader will start consuming the second request
    // when reading the body/headers of the first. If it does,
    // immediately process that data here, otherwise it will be
    // lost forever. If the reader doesn't start reading those bytes,
    // then the TCP server will just say that the client is ready
    // to be read from again.
    while #bottom_test io.reader_get_buffered(&reader) > 0 {
        if !parse_request(&req, &reader) {
            return false;
        }

        res: Response;
        response_init(&res);
        defer response_free(&res);

        // Process the request!
        tcp.pipeline->process(&req, &res);

        response_finalize(&res);
        send_response(&res, s);
    }

    return true;
}

#local
use_gc_allocator_in_current_scope :: macro (gc: &alloc.gc.GCState) {
    old_allocator := context.allocator;
    context.allocator = alloc.as_allocator(gc);
    defer {
        alloc.gc.clear(gc);
        context.allocator = old_allocator;
    }
}

