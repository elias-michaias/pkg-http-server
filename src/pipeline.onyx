package http

Pipeline :: struct {
    steps: [..] Pipe;

    free    :: pipeline_free
    add     :: pipeline_add_step
    process :: pipeline_process

    Action :: enum {
        Proceed;
        Finish;
    }
}

Pipe :: struct {
    handler: (data: rawptr, req: ^Request, res: ^Response) -> Pipeline.Action;
    data: rawptr;
}

pipeline :: () -> Pipeline {
    p: Pipeline;
    p.steps = make(typeof p.steps, allocator=long_term_allocator);
    return p;
}

#package
pipeline_free :: (p: ^Pipeline) {
    delete(^p.steps);
}

#package
pipeline_add_step :: (p: ^Pipeline, s: $T) where Pipeable(T) {
    step := convert_to_pipe(s);
    p.steps << step;
}

#package
pipeline_process :: (p: ^Pipeline, req: ^Request, res: ^Response) -> Pipeline.Action {
    for p.steps {
        if it.handler(it.data, req, res) == .Finish {
            return .Finish;
        }
    }

    return .Proceed;
}


convert_to_pipe :: #match {}
Pipeable :: interface (T as t) {
    { convert_to_pipe(t) } -> Pipe;
}


#overload
convert_to_pipe :: macro (p: ^Pipeline) => Pipe.{pipeline_process, p};
