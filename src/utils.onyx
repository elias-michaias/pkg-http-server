package http

HTTP_Method :: enum {
    UNKNOWN;
    GET;
    HEAD;
    POST;
    PUT;
    DELETE;
    CONNECT;
    OPTIONS;
    TRACE;
    PATCH;

    ALL;
}

urlencode :: (s: str, allocator := context.allocator) -> str {
    out := make([..] u8, s.count, allocator=allocator);

    for ch: s do switch ch {
        //
        // This list was taken from:
        // https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding
        match(#char ":", "%3A");
        match(#char "/", "%2F");
        match(#char "?", "%3F");
        match(#char "#", "%23");
        match(#char "[", "%5B");
        match(#char "]", "%5D");
        match(#char "@", "%40");
        match(#char "!", "%21");
        match(#char "$", "%24");
        match(#char "&", "%26");
        match(#char "'", "%27");
        match(#char "(", "%28");
        match(#char ")", "%29");
        match(#char "*", "%2A");
        match(#char "+", "%2B");
        match(#char ",", "%2C");
        match(#char ";", "%3B");
        match(#char "=", "%3D");
        match(#char "%", "%25");
        match(#char " ", "%20");

        case #default do out << ch;

        match :: macro (from: u8, to: str) {
            //
            // How's this for a one-liner
            case from do for to do out << it;
        }
    }

    return out;
}

urldecode :: (s: str, allocator := context.allocator) -> str {
    out := make([..] u8, s.count, allocator=allocator);

    i := iter.as_iterator(s);
    defer iter.close(i);

    for #no_close ch: i {
        if *ch == #char "%" {
            a, e  := iter.take_one(i, no_close=true);
            b, e' := iter.take_one(i, no_close=true);

            n := u8.[*a, *b];

            v := conv.str_to_i64(n, base=16);
            switch v {
                match(0x3A, #char ":");
                match(0x2F, #char "/");
                match(0x3F, #char "?");
                match(0x23, #char "#");
                match(0x5B, #char "[");
                match(0x5D, #char "]");
                match(0x40, #char "@");
                match(0x21, #char "!");
                match(0x24, #char "$");
                match(0x26, #char "&");
                match(0x27, #char "'");
                match(0x28, #char "(");
                match(0x29, #char ")");
                match(0x2A, #char "*");
                match(0x2B, #char "+");
                match(0x2C, #char ",");
                match(0x3B, #char ";");
                match(0x3D, #char "=");
                match(0x25, #char "%");
                match(0x20, #char " ");

                match :: macro (from: i64, to: u8) {
                    case from do out << to;
                }
            }

        } elseif *ch == #char "+" {
            out << #char " ";
        } else {
            out << *ch;
        }
    }

    return out;
}

#package known_mimetypes: Map(str, str);
guess_mime_type :: (filename: str) -> str {
    extension := filename[string.last_index_of(filename, #char ".")+1 .. filename.count];

    if known_mimetypes->has(extension) {
        return known_mimetypes[extension];
    }

    //
    // This is a small list of mime types that should be expanded
    // on in the future. I don't know if it is worth pulling all
    // of the known mime types from:
    //
    // https://www.iana.org/assignments/media-types/media-types.xhtml
    //
    // or if that is a little overkill.
    switch extension {
        case "html" do return "text/html";
        case "css"  do return "text/css";
        case "js"   do return "text/javascript";
        case "xml"  do return "text/xml";

        case "jpg", "jpeg"  do return "image/jpeg";
        case "png"          do return "image/png";

        case #default do return "application/text";
    }
}

set_mime_type :: (ext: str, type: str) {
    known_mimetypes->put(ext, type);
}


#package {
    // The http-server library uses a single allocator across all uses,
    // even if multiple applications are used (for some reason).

    long_term_allocator: Allocator;
    short_term_allocator: Allocator;
    short_term_arena: arena.ArenaState;

    prepare_allocators :: #init () {
        long_term_allocator = context.allocator;
        short_term_arena = arena.make(long_term_allocator, 1 * 1024 * 1024);
        short_term_allocator = arena.make_allocator(^short_term_arena);

        known_mimetypes->init();
    }
}




// @Relocate
#overload #precedence 1000
json.encode :: (w: ^io.Writer, data: any) -> json.Encoding_Error {
    use runtime.info;

    info := get_type_info(data.type);

    switch info.kind {
        case .Basic {
            io.write_format_va(w, "{}", .[data]);
        }

        case .Array {
            io.write(w, "[");

            a := cast(^Type_Info_Array) info;
            arr := data.data;

            for i: a.count {
                if i != 0 do io.write(w, ",");

                json.encode(w, any.{ ~~(cast(^u8) arr + get_type_info(a.of).size * i), a.of });
            }

            io.write(w, "]");
        }

        case .Slice, .Dynamic_Array {
            if data.type == str {
                io.write_format_va(w, "{\"}", .[data]);
                break;
            }

            io.write(w, "[");

            a := cast(^Type_Info_Dynamic_Array) info;
            arr := cast(^core.array.Untyped_Array) data.data;
            data  := arr.data;
            count := arr.count;

            for i: count {
                if i != 0 do io.write(w, ",");

                json.encode(w, any.{ ~~(cast(^u8) data + get_type_info(a.of).size * i), a.of });
            }

            io.write(w, "]");
        }

        case .Distinct {
            d := cast(^Type_Info_Distinct) info;
            json.encode(w, any.{ data.data, d.base_type });
        }

        case .Struct {
            s := cast(^runtime.info.Type_Info_Struct) info;

            io.write(w, "{");

            for ^member: s.members {
                if member != s.members.data do io.write(w, ",");
                json.encode(w, member.name);
                io.write(w, ":");
                json.encode(w, any.{ ~~(cast(^u8) data.data + member.offset), member.type });
            }
            io.write(w, "}");
        }

        case #default {
            return .Unsupported_Type;
        }
    }
}

Json_Key :: struct {key: str;}

json_to_struct :: #match {
    macro (value: json.Value, out: ^$T) {
        json_to_struct :: json_to_struct
        json_to_struct(value, T, cast(rawptr) out);
    },

    (value: json.Value, type: type_expr, out: rawptr) {
        use runtime.info;

        t_info := get_type_info(type);
        switch t_info.kind {
            case .Basic do switch type {
                // These functions handle the cases where the types do
                // not match, so no additional checks are needed here.
                case bool     do *cast(^bool) out =    value->as_bool();
                case i32, u32 do *cast(^i32)  out = ~~(value->as_int());
                case i64, u64 do *cast(^i64)  out =    value->as_int();
                case f32      do *cast(^f32)  out = ~~(value->as_float());
                case f64      do *cast(^f64)  out =    value->as_float();
            }

            case .Array {
                a_info := cast(^Type_Info_Array) t_info;

                for i: a_info.count {
                    json_to_struct(value[i], a_info.of, cast(^u8) out + size_of(a_info.of) * i);
                }
            }

            case .Slice {
                // Strings are handled differently
                if type == str {
                    *cast(^str) out = string.alloc_copy(value->as_str());
                    return;
                }

                s_info := cast(^Type_Info_Slice) t_info;
                s := cast(^core.array.Untyped_Array) out;

                if s.count == 0 {
                    if s.data != null {
                        return;
                    }

                    to_copy := value->as_array();

                    s.data = calloc(size_of(s_info.of) * to_copy.count);
                    s.count = to_copy.count;
                }

                for i: s.count {
                    json_to_struct(value[i], s_info.of, cast(^u8) s.data + size_of(s_info.of) * i);
                }
            }

            case .Struct {
                s_info := cast(^Type_Info_Struct) t_info;

                for^ member: s_info.members {
                    key := member.name;
                    if tag := core.array.first(member.tags, #(it.type == Json_Key)); tag != null {
                        key = (cast(^Json_Key) tag.data).key;
                    }

                    json_to_struct(value[key], member.type, cast(^u8) out + member.offset);
                }
            }

            case .Distinct {
                d_info := cast(^Type_Info_Distinct) t_info;
                json_to_struct(value, d_info.base_type, out);
            }
        }
    }
}
