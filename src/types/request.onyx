package http

Request :: struct {
    app: ^Application;

    method: HTTP_Method;

    // base_endpoint is what was originally requested.
    // endpoint is modified through request routing,
    // and ends up being the final route that was
    // matched.
    base_endpoint: str;
    endpoint: str;

    headers: Map(str, str);
    query:   Map(str, str);
    cookies: Map(str, str);

    address: net.Socket_Address;

    body: Request_Body;
}

Request_Body :: struct {
    contents: str;
}


#inject
Request.query_param :: macro (req: ^Request, $type: type_expr, param: str, default := type.{}) -> type {
    if !req.query->has(param) {
        return default;
    }

    // Strings are handled differently because 
    // conv.parse_any expects the string ot be
    // enclosed in quotes, but strings passed
    // as parameters will not be enclosed in
    // quotes.

    @Cleanup
    // This uses type punning to escape the fact that
    // you have to return the correct type here. This
    // does not affect the runtime at all. Currently,
    // #if does not work with compile time parameters
    // in macros which is why this is necessary.
    if type == str {
        return *cast(^type) ^req.query[param];
    }

    v: type;
    if core.conv.parse_any(^v, req.query[param]) {
        return v;
    }

    return default;
}

#package
request_free :: (req: ^Request) {
    delete(^req.base_endpoint);
    delete(^req.body);
    delete(^req.headers);
    delete(^req.query);
}


parse_request :: #match {}

#overload
parse_request :: (req: ^Request, s: str) {
    stream := io.buffer_stream_make(s, fixed=true, write_enabled=false);
    r := io.reader_make(^stream);
    defer io.reader_free(^r);
    
    parse_request(req, ^r);
}

#overload
parse_request :: (req: ^Request, r: ^io.Reader) {
    @ErrorHandling
    {
        request_line := r->read_line(inplace=true);

        method := string.read_until(^request_line, #char " ");
        string.advance(^request_line);

        m := core.array.first(runtime.info.enum_values(HTTP_Method), #(it.name == method));
        if m == null do req.method = .UNKNOWN;
        else         do req.method = ~~m.value;

        route := string.read_until(^request_line, #char " ") |> string.alloc_copy();
        string.advance(^request_line);

        req.endpoint = string.read_until(^route, #char "?") |> string.alloc_copy();
        req.base_endpoint = req.endpoint;

        @ErrorHandling
        while !string.is_empty(route) {
            string.advance(^route);

            key   := string.read_until(^route, #char "=") |> urldecode();
            string.advance(^route);
            value := string.read_until(^route, #char "&") |> urldecode();

            req.query[key] = value;
        }
    }

    while true {
        line := r->read_line(inplace=true);
        if line == "\r\n" do break;

        header := string.read_until(^line, #char ":")
               |> string.alloc_copy();
        string.advance(^line, 2);

        value := line
              |> string.trim_end(#char "\n")
              |> string.trim_end(#char "\r")
              |> string.alloc_copy();

        if header == "Cookie" {
            // Parse cookies
            while true {
                pair := string.read_until(^value, "; ");
                if pair.count == 0 do break;

                k    := string.read_until(^pair, #char "=");
                string.advance(^pair);
                v    := pair;

                req.cookies[k] = v;

                string.advance(^value, 2);
            }

            continue;
        }

        req.headers[header] = value;
    }

    req.body = .{ r->read_all() };
}


#inject
Request_Body.json :: (body: ^Request_Body) -> json.Json {
    return json.decode(body.contents);
}

#inject
Request_Body.json_as :: macro (body: ^Request_Body, $T: type_expr) -> T {
    json_to_struct :: json_to_struct

    j := json.decode(body.contents);
    defer json.free(j);

    out: T;
    json_to_struct(j.root, ^out);

    return out;
}

