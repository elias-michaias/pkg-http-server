package http.server

use runtime
use core.encoding.json
use core.memory

Request :: struct {
    method: HTTP_Method;

    // base_endpoint is what was originally requested.
    // endpoint is modified through request routing,
    // and ends up being the final route that was
    // matched.
    endpoint: str;
    _processed_endpoint: [] Route.Elem;

    headers:    Map(str, str);
    query:      Map(str, str);
    cookies:    Map(str, str);
    url_params: Map(str, str);

    address: Request_Address;

    body: Request_Body;
}

Request_Address :: struct {
    ip: str;
}

Request_Body :: struct {
    contents: str;
    request:  &Request;
}

Request_Body_Form :: struct {
    fields: Map(str, str);
}


#inject
Request.query_param :: macro (req: &Request, $type: type_expr, param: str, default := type.{}) -> type {
    use core

    if !(req.query->has(param)) {
        return default;
    }

    // Strings are handled differently because 
    // conv.parse_any expects the string ot be
    // enclosed in quotes, but strings passed
    // as parameters will not be enclosed in
    // quotes.

    // @Cleanup
    // This uses type punning to escape the fact that
    // you have to return the correct type here. This
    // does not affect the runtime at all. Currently,
    // #if does not work with compile time parameters
    // in macros which is why this is necessary.
    if type == str {
        return *cast(&type) &req.query[param];
    }

    v: type;
    if core.conv.parse_any(&v, req.query[param]) {
        return v;
    }

    return default;
}

#package
request_free :: (req: &Request) {
    delete(&req.headers);
    delete(&req.query);
    delete(&req.cookies);
    delete(&req.url_params);
}

#inject
Request_Body.is_json :: (body: &Request_Body) -> bool {
    content_type := body.request.headers["content-type"];

    if content_type == "application/json" do return true;

    if string.starts_with(content_type, "application/")
        && string.ends_with(content_type, "+json") do return true;
    
    return false;
}

#inject
Request_Body.json :: (body: &Request_Body) -> json.Json {
    if !(body->is_json()) do return .{};

    return json.decode(body.contents);
}

#inject
Request_Body.json_as :: macro (body: &Request_Body, $T: type_expr) -> T {
    json :: json

    j := json.decode(body.contents);
    defer json.free(j);

    out: T;
    json.to_any(j.root, &out);

    return out;
}

#inject
Request_Body.is_form :: (body: &Request_Body) -> bool {
    content_type := body.request.headers["content-type"];
    content_type  = string.read_until(&content_type, ";");
    return content_type == "application/x-www-form-urlencoded"
        || content_type == "multipart/form-data";
}

#inject
Request_Body.form :: (body: &Request_Body) -> Request_Body_Form {
    out := make(Map(str, str));

    content_type := body.request.headers["content-type"];
    content_type  = string.read_until(&content_type, ";");

    content := body.contents;
    switch content_type {
        case "application/x-www-form-urlencoded" {
            parse_url_encoded_key_value(&out, &content);
        }

        case "multipart/form-data" {
            parse_multipart_form_data(body.request, &out);
        }
    }

    return .{ out };
}

#inject
Request_Body.form_into :: (body: &Request_Body, $T: type_expr) -> T {
    use runtime.info {get_type_info}

    out: T;

    form := body->form();
    defer delete(&form.fields);

    for& member: get_type_info(T)->as_struct().members {
        if member.type == str {
            *cast(&str, memory.ptr_add(&out, member.offset)) = form.fields[member.name];
        } else {
            core.conv.parse_any(memory.ptr_add(&out, member.offset), member.type, form.fields[member.name]);
        }
    }

    return out;
}

#package
parse_multipart_form_data :: (r: &Request, dest: &Map(str, str)) {
    _, boundary_map := string.bisect(r.headers["content-type"], #char ";");
    key, value      := string.bisect(boundary_map, #char "=");
    string.strip_leading_whitespace(&key);
    string.strip_leading_whitespace(&value);

    if key != "boundary" {
        return;
    }

    boundary := value;
    if value[0] == #char "\"" {
        // Remove "" if they are present around boundary name
        boundary = value[1 .. value.length - 1];
    }

    boundary_delimiter := core.tprintf("--{}\r\n", boundary);

    content := r.body.contents;
    while true {
        line := string.read_until(&content, #char "\n");
        string.advance(&content, 1);
        if content.length == 0 do break;

        part_name := "";
        while !string.starts_with(content, "\r\n") {
            key, value := parse_header(&content);

            if key == "content-disposition" {
                string.strip_leading_whitespace(&value);
                if !string.starts_with(value, "form-data;") do continue;
                string.advance(&value, "form-data;".length);

                string.strip_leading_whitespace(&value);
                if !string.starts_with(value, "name=\"") do continue;
                string.advance(&value, "name=\"".length);

                part_name = string.read_until(&value, #char "\"");
            }
        }

        part_value := string.read_until(&content, core.tprintf("\r\n--{}", boundary))
                      |> string.strip_leading_whitespace();

        dest->put(part_name, part_value);

        string.advance_line(&content);
    }
}


#inject
Request_Body_Form.field :: (form: &Request_Body_Form, $type: type_expr, field: str) -> ? type {
    if !(form.fields->has(field)) {
        return .{};
    }

    if type == str {
        return *cast(&type) &form.fields[field];
    }

    v: type;
    if core.conv.parse_any(&v, form.fields[field]) {
        return v;
    }

    return .{};
}
