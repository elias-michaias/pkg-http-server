package http

Application :: struct {
    server: ^net.TCP_Server;
    pipeline: Pipeline;

    session_state:     alloc.heap.AutoHeapState;
    session_allocator: Allocator;

    pipe  :: application_pipe;
    serve :: application_serve;
}

application :: () -> Application {
    app: Application;

    app.pipeline = pipeline();

    return app;
}

#package
application_pipe :: (app: ^Application, s: $T) {
    app.pipeline->add(s);
}

#package
application_serve :: (app: ^Application, port: u32) {
            
    app.session_state = alloc.heap.auto_heap_make();
    app.session_allocator = alloc.as_allocator(^app.session_state);

    app.server = net.tcp_server_make(max_clients=4);
    while !app.server->listen(~~port) {
        core.printf("Failed to bind to port {}.\n", port);
        port += 1;
    }

    log(core.tprintf("Serving on port {}", port));
    app.server->handle_events() {
        @TODO // I don't think I have to handle these,
        // as it makes no difference when a TCP connection
        // opens or closes. Only the data sent is important.
        case .Connection ---
        case .Disconnection ---

        case .Data {
            data := cast(^core.net.TCP_Event.Data) it.data;

            old_allocator := context.allocator;
            context.allocator = app.session_allocator;
            defer {
                alloc.heap.auto_heap_clear(^app.session_state);
                context.allocator = old_allocator;
            }

            req: Request;
            req.app = app;
            req.address = data.client.address;
            parse_request(^req, data.contents);
            defer request_free(^req);

            res: Response;
            defer response_free(^res);

            app.pipeline->process(^req, ^res);
            response_finalize(^res);
            send_response(^res, ^data.client.socket);
        }
    }
}

