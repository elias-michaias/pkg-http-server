package http.server

Application :: struct {
    server: &net.TCP_Server;
    pipeline: Pipeline;

    session_gc: alloc.gc.GCState;
}

#inject Application {
    pipe  :: application_pipe;
    serve :: application_serve;
}

application :: () -> Application {
    app: Application;

    app.pipeline = pipeline();

    return app;
}

#package
application_pipe :: #match #local {}

#overload
application_pipe :: (app: &Application, s: HTTP_Handler) {
    app.pipeline->add(s);
}

#overload
application_pipe :: (app: &Application, s: $T) {
    app.pipeline->add(s);
}


Serve_Status :: enum {
    Success;
    Failed_To_Bind;
}

#package
application_serve :: (app: &Application, port: u32) -> Serve_Status {
    app.session_gc = alloc.gc.make();

    app.server = net.tcp_server_make(max_clients=4);
    app.server.emit_data_events = false;

    // Allows the server to be immediately restarted. Not
    // the safest, but it is fine for a development instance.
    app.server.socket->setting(.ReuseAddress, 1);

    if !(app.server->listen(~~port)) {
        log(.Error, "HTTP-Server", core.tprintf("Failed to bind to port {}.\n", port));
        return .Success;
    }

    // os.register_fault_handler(app, (app: &Application) {
    //     log(.Info, "HTTP-Server", "Stopping HTTP server...");
    //     app.server->stop();
    // });

    log(.Info, "HTTP-Server", core.tprintf("Serving on port {}", port));
    app.server->handle_events() {
        case .Connection {
            // Enable non-blocking communication on all sockets
            cast(&core.net.TCP_Event.Connection, it.data).client.socket->setting(.NonBlocking, 1);
        }

        case .Ready {
            ready_client := cast(&core.net.TCP_Event.Ready, it.data).client;
            if ready_client.socket.vtable == null || ready_client.state != .Alive {
                log(.Warning, "HTTP-Server", "Discarding dead client");
                ready_client->read_complete();
                continue;
            }

            use_gc_allocator_in_current_scope(&app.session_gc);
            defer alloc.clear_temp_allocator();

            if !handle_request(app, &ready_client.address, &ready_client.socket) {
                // If the request fails to parse, shutdown the connection.
                // Likely, this is actually due to the socket being empty
                // and/or already closed, but you can't tell until you try
                // to read from it.
                app.server->kill_client(ready_client);

            } else {
                ready_client->read_complete();
            }
        }
    }
}

#local
handle_request :: (app: &Application, req_address: &net.Socket_Address, s: &net.Socket) -> bool {
    req := Request.{
        app = app,
        address = *req_address
    };
    defer request_free(&req);

    reader := io.reader_make(s);
    defer io.reader_free(&reader);

    if !parse_request(&req, &reader) {
        return false;
    }

    res: Response;
    response_init(&res);
    defer response_free(&res);

    // Process the request!
    app.pipeline->process(&req, &res);

    response_finalize(&res);
    send_response(&res, s);

    return true;
}

#local
use_gc_allocator_in_current_scope :: macro (gc: &alloc.gc.GCState) {
    old_allocator := context.allocator;
    context.allocator = alloc.as_allocator(gc);
    defer {
        alloc.gc.clear(gc);
        context.allocator = old_allocator;
    }
}

