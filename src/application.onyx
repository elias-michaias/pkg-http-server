package http

Application :: struct {
    server: ^net.TCP_Server;
    pipeline: Pipeline;

    session_state:     alloc.gc.GCState;
    session_allocator: Allocator;

    pipe  :: application_pipe;
    serve :: application_serve;
}

application :: () -> Application {
    app: Application;

    app.pipeline = pipeline();

    return app;
}

#package
application_pipe :: #match #local {}

#overload #precedence 1
application_pipe :: (app: ^Application, s: HTTP_Handler) {
    app.pipeline->add(s);
}

#overload #precedence 2
application_pipe :: (app: ^Application, s: $T) {
    app.pipeline->add(s);
}

#package
application_serve :: (app: ^Application, port: u32) {
    app.session_state = alloc.gc.make();
    app.session_allocator = alloc.as_allocator(^app.session_state);

    app.server = net.tcp_server_make(max_clients=4);
    app.server.emit_data_events = false;

    // Allows the server to be immediately restarted. Not
    // the safest, but it is fine for a development instance.
    app.server.socket->setting(.ReuseAddress, 1);

    if !(app.server->listen(~~port)) {
        core.printf("Failed to bind to port {}.\n", port);
        os.exit(1);
    }

     os.register_fault_handler(app, (app: ^Application) {
         app.server->stop();
     });

    log(core.tprintf("Serving on port {}", port));
    app.server->handle_events() {
        case .Connection {
            // Enable non-blocking communication on all sockets
            (cast(^core.net.TCP_Event.Connection) it.data).client.socket->setting(.NonBlocking, 1);
        }

        case .Ready {
            old_allocator := context.allocator;
            context.allocator = app.session_allocator;
            defer {
                alloc.gc.clear(^app.session_state);
                context.allocator = old_allocator;

                alloc.clear_temp_allocator();
            }

            ready_client := cast(^core.net.TCP_Event.Ready) it.data;
            defer ready_client.client->read_complete();

            reader := io.reader_make(^ready_client.client.socket, greedy=true);
            defer io.reader_free(^reader);

            req: Request;
            defer request_free(^req);

            req.app = app;
            req.address = ready_client.client.address;
            if !parse_request(^req, ^reader) {
                // If the request fails to parse, shutdown the connection.
                // Likely, this is actually due to the socket being empty
                // and/or already closed, but you can't tell until you try
                // to read from it.
                app.server->kill_client(ready_client.client);
                continue;
            }

            res: Response;
            response_init(^res);
            defer response_free(^res);

            app.pipeline->process(^req, ^res);
            response_finalize(^res);
            send_response(^res, ^ready_client.client.socket);
        }
    }
}

